ok now that you have git access , I have my public repository for this project here

https://github.com/PabloBorda/GoldenThinkerExtractor

Can you see any crucial difference with our last version by which we are getting this error on the minified version generated by webpack ? We were not having this problem .  The following is my local last version: 

content.js

// CORS: 'sha256-3woF8BZ54TeXM+czaH3aXoaJsVpiamuAKFsXDykAR/Q='

function attach_event_listeners(){
  // Save selectors to cookies
  console.log("Attaching event listener to start/stop_web_crawl_message button");

  const startstop_web_crawl_messageButton = document.getElementById("startButton");
  
  startstop_web_crawl_messageButton.addEventListener("click", function() {
      if (this.innerHTML === "Start") {
        console.log("Start button clicked");
        this.style.backgroundColor = "#f44336";
        this.innerHTML = "stop_web_crawl_message";
        chrome.tabs.query({ active: true, currentWindow: true }, function(tabs) {
          console.log("Sending 'start_web_crawl_message' message to background script");
          chrome.runtime.sendMessage({ action: "start_web_crawl_message", tab: tabs[0] }, function(response) {
            // Close the popup window after sending the message
            window.close();
          });
        });
      } else {
        console.log("stop_web_crawl_message button clicked");
        this.style.backgroundColor = ""; // Reset button color
        this.innerHTML = "Start";
        console.log("Sending 'stop_web_crawl_message' message to background script");
        chrome.runtime.sendMessage({ action: "stop_web_crawl_message", tab: tabs[0] }, function(response) {
          // Close the popup window after sending the message
          window.close();
        });
      }
  });


  document.getElementById("downloadButton").addEventListener("click", function() {
      console.log("downloading...");
      const filenameInput = document.getElementById("filename");
      const filename = filenameInput.value.trim() || "download"; // Use a default filename if none is provided

      chrome.storage.local.get(["globalResultsArray"], function(data) {
          if (data.globalResultsArray) {
              const jsonString = JSON.stringify(data.globalResultsArray, null, 2);
              const blob = new Blob([jsonString], { type: "application/json" });
              const url = URL.createObjectURL(blob);

              const a = document.createElement("a");
              a.href = url;
              a.download = `${filename}.json`; // Use the user-specified filename
              document.body.appendChild(a);
              a.click();

              document.body.removeChild(a);
              URL.revokeObjectURL(url);
          } else {
              console.log("No data to download.");
          }
      });
  });

  // Clear selectors from cookies and text area
  document.getElementById("clearButton").addEventListener("click", function() {
    console.log("clear");
    chrome.storage.local.clear(function() {
      var error = chrome.runtime.lastError;
      if (error) {
          console.error(error);
      } else {
          console.log('Data cleared from chrome.storage.local');
      }
    });
  });

  document.getElementById("addElementButton").addEventListener("click", function() {
    const nameInput = document.getElementById("elementName");
    const selectorInput = document.getElementById("elementSelector");
    const name = nameInput.value.trim();
    const selector = selectorInput.value.trim();

    if (name && selector) {
        chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
            const currentcurrent_tab_id = tabs[0].id.toString(); // Convert tab ID to string for use as a key
            const newElement = {name, selector};

            // Retrieve the current list of selectors for the tab, add the new one, and save it back
            chrome.storage.local.get([currentcurrent_tab_id], function(result) {
                const currentSelectors = result[currentcurrent_tab_id] ? result[currentcurrent_tab_id] : [];
                currentSelectors.push(newElement);
                let storageObject = {};
                storageObject[currentcurrent_tab_id] = currentSelectors;

                chrome.storage.local.set(storageObject, function() {
                    console.log('Selector saved for tab ID:', currentcurrent_tab_id);
                    // Clear inputs and refresh the list of selectors
                    nameInput.value = '';
                    selectorInput.value = '';
                    loadSelectorsForCurrentTab();
                });
            });
        });
    } else {
        alert("Please fill in both name and selector fields.");
    }
  });


}

document.addEventListener("DOMContentLoaded", function() {
  console.log("DOMContentLoaded");
  chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
    const url = new URL(tabs[0].url);
    const domain = url.hostname;
    document.getElementById("domainName").textContent = domain;
  });
  attach_event_listeners();
  loadSelectorsForCurrentTab(); // Load selectors for the current tab

  var tablinks = document.getElementsByClassName("tablinks");
  for (let i = 0; i < tablinks.length; i++) {
      tablinks[i].addEventListener('click', function(event) {
          var tabName = this.getAttribute('data-tab');
          openTab(event,tabName);
      });

      // Automatically open the first tab or a specific tab
      if(tablinks.length > 0) {
        tablinks[0].click();
      }
    }

    

    function getFaviconUrl(url) {
      // Assuming favicon is at the root directory as a fallback
      let faviconUrl = `${url.protocol}//${url.hostname}/favicon.ico`;
    
      // Attempt to fetch the favicon specified in the page's link element
      function findFaviconInDocument() {
        const link = document.querySelector("link[rel~='icon']");
        if (link) {
          return link.href;
        }
        return '';
      }

      chrome.scripting.executeScript({
        target: {current_tab_id: url.id},
        function: findFaviconInDocument,
      }, (injectionResults) => {
        for (const frameResult of injectionResults)
          if (frameResult.result && frameResult.result !== '') {
            faviconUrl = frameResult.result;
            break;
          }
        document.getElementById('target_favicon').src = faviconUrl;
      });
    
      return faviconUrl; // This will return the default favicon path or the updated one if found
    }

    
    // Fetch and display the favicon and domain
    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
      const url = new URL(tabs[0].url);
      document.getElementById("domainName").textContent = url.hostname;
      document.getElementById('target_favicon').src = `${url.protocol}//${url.host}/favicon.ico`;
    });

});

function loadSelectorsForCurrentTab() {
  chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
      const currentcurrent_tab_id = tabs[0].id.toString();
      chrome.storage.local.get([currentcurrent_tab_id], function(result) {
          const selectors = result[currentcurrent_tab_id] ? result[currentcurrent_tab_id] : [];
          const elementsList = document.getElementById("elementsList");
          elementsList.innerHTML = ''; // Clear existing list

          selectors.forEach((element, index) => {
              const elementItem = document.createElement("div");
              elementItem.className = "element-item";
              elementItem.innerHTML = `<td>${element.name}: ${element.selector}</td><td></td><td></td><td><button class="removeElementButton" data-index="${index}">X</button></td>`;
              elementsList.appendChild(elementItem);

              // Add remove functionality
              elementItem.querySelector(".removeElementButton").addEventListener("click", function() {
                  removeSelectorFromCurrentTab(index);
              });
          });
      });
  });
}


function removeSelectorFromCurrentTab(index) {
  chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
      const currentcurrent_tab_id = tabs[0].id.toString();
      chrome.storage.local.get([currentcurrent_tab_id], function(result) {
          let selectors = result[currentcurrent_tab_id];
          if (selectors) {
              selectors.splice(index, 1); // Remove the selector at the specified index
              let storageObject = {};
              storageObject[currentcurrent_tab_id] = selectors;

              chrome.storage.local.set(storageObject, function() {
                  console.log('Selector removed for tab ID:', currentcurrent_tab_id);
                  loadSelectorsForCurrentTab(); // Refresh the list of selectors
              });
          }
      });
  });
}


function openTab(evt, tabName) {
  var i,tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  var targetTab = document.getElementById(tabName);
  if (targetTab) {
    targetTab.style.display = "block";
    evt.currentTarget.className += " active";
  } else {
    console.error("Tab not found: ", tabName);
  }
}






background.js: 

import { extractFiltersAndValues } from './com_goldenthinkerextractor_filters_for_website/filters.js';


chrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {
    if (message.action === "start_web_crawl_message") {
        let tab = message.tab.id;
        try {
            await chrome.scripting.executeScript({
                target: {current_tab_id: tab},
                function: mainScript
            });
            console.log("Script injected into tab " + tab);
            sendResponse({status: "success"});
        } catch (error) {
            console.error("Error injecting script into tab " + tab, error);
            sendResponse({status: "error", message: error.message});
        }
    } else if (message.action === "stop_web_crawl_message") {
        console.log("Script stopped.");
        // Implement stopping logic if necessary
        sendResponse({status: "stopped"});
    }
    return true; // Keep the message channel open for the response
});
  

async function mainScript() {
  

    async function getContainer() {
        return new Promise((resolve, reject) => {
            const containerSelector = "#search-results-container";
            const checkExist = setInterval(() => {
                const container = document.querySelector(containerSelector);
                if (container) {
                    clearInterval(checkExist);
                    resolve(container);
                }
            }, 100); // Check every 100ms
        });
    }
  
/*     async function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    } */

    async function waitForDomChanges(selector, timeout = 30000) {
        return new Promise(async (resolve, reject) => { // Note the async keyword here
            const container = await getContainer(); // Properly await the container
            if (!container) {
                reject(new Error(`Container with selector "${selector}" not found.`));
                return;
            }
    
            // Options for the observer (which mutations to observe)
            const config = { childList: true, subtree: true };
    
            // Callback function to execute when mutations are observed
            const callback = function(mutationsList, observer) {
                observer.disconnect(); // Stop observing
                resolve(); // Resolve the promise as changes are detected
            };
    
            // Create an instance of the observer with the callback function
            const observer = new MutationObserver(callback);
    
            // Start observing the target node for configured mutations
            observer.observe(container, config);
    
            // Set a timeout to reject the promise if no changes are detected within the specified time
            setTimeout(() => {
                observer.disconnect(); // Stop observing
                reject(new Error(`Timeout reached. No changes detected in the container within ${timeout} ms.`));
            }, timeout);
        });
    }
  
    async function extractDataFromPage() {

        let results = [];
  
        function addObjectIfUnique(newObj) {
          // Busca en el arreglo si ya existe un objeto con el mismo nombre
          const exists = results.find(obj => obj.name === newObj.name);
          // Si no existe, inserta el nuevo objeto
          if (!exists) {
              results.push(newObj);
              console.log(`Objeto con nombre ${newObj.name} agregado.`);
          } else {
              console.log(`Objeto con nombre ${newObj.name} ya existe.`);
          }
        }

        function sanitizeString(str) {
            return str.replace(/[^\x20-\x7E]+/g, ""); // Removes non-printable characters
            // Add more sanitization rules as needed
        }

        console.log("extractDataFromPage..");
        // Directly mapping to the attributes for photos and lead panels
        let photos = Array.from(document.querySelectorAll("[data-anonymize='headshot-photo']")).map(el => el.getAttribute("src"));
        let leadPanels = Array.from(document.querySelectorAll("[data-control-name='view_lead_panel_via_search_lead_name']")).map(el => el.getAttribute("href"));
        // Mapping to text content for other fields
        let personNames = Array.from(document.querySelectorAll("span[data-anonymize='person-name']")).map(el => el.textContent.trim());
        let titles = Array.from(document.querySelectorAll("[data-anonymize='title']")).map(el => el.textContent.trim());
        let jobTitles = Array.from(document.querySelectorAll("[data-anonymize='job-title']")).map(el => el.textContent.trim());
        let locations = Array.from(document.querySelectorAll("[data-anonymize='location']")).map(el => el.textContent.trim());
        let companies = Array.from(document.querySelectorAll('a[data-anonymize="company-name"]')).map(el => el.textContent.trim());
        let abouts = Array.from(document.querySelectorAll('.flex.flex-column.justify-space-between')).map(el => el.textContent.trim());
    
        // Assuming all arrays are of the same length. If not, additional checks are needed.
        for (let i = 0; i < personNames.length; i++) {
            let result = {
                photo: photos[i], // Directly using the mapped src attribute
                leadPanel: sanitizeString(leadPanels[i]), // Directly using the mapped href attribute
                name: sanitizeString(personNames[i]),
                title: sanitizeString(titles[i]),
                jobTitle: sanitizeString(jobTitles[i]),
                location: sanitizeString(locations[i]),
                company: sanitizeString(companies[i]), // Directly using the mapped text content
                about: sanitizeString(abouts[i])
            };
            addObjectIfUnique(result);
        }
        console.log("Data Obtained");
        console.log(JSON.stringify(results, null, 2)); // Pretty print the results
        return results;
    } 
  
/*     async function sendResultsToServer(results) {
        console.log("Sending results to server...");
        try {
            // Validate JSON before sending
            const jsonData = JSON.stringify(results);
            const response = await fetch("http://127.0.0.1:8080/index", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: jsonData
            });
    
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const jsonResponse = await response.json();
            console.log("Results sent successfully", jsonResponse);
        } catch (error) {
            console.error("Error sending results to server:", error);
        }
    }
   */




    async function storeResultsLocally(newResults) {


        // Retrieve the existing results array from storage
        chrome.storage.local.get(["globalResultsArray"], function(data) {
            let completeObject = {
                filters: [],
                leads: []
            };
            if (!completeObject.filters){
                completeObject.filter = extractFiltersAndValues();
            }
            completeObject.leads = data.globalResultsArray || [];
            // Append new results to the existing array
            completeObject.leads.push(...newResults);
            
            // Store the updated array back into chrome.storage
            chrome.storage.local.set({ "globalResultsArray": completeObject.leads }, function() {
                console.log("New results have been added to the global array.");
            });
        });
    }


    async function navigateToNextPage() {
        const nextPageButton = document.querySelector(".artdeco-pagination__button--next:not([disabled])");
        if (nextPageButton) {
            nextPageButton.click();
            waitForDomChanges("#search-results-container")
                .then(() => {
                    console.log("New DOM data loaded in the container.");
                    scrollDown();
                })
                .catch(error => console.error(error.message));
            return true;
        } else {
            console.log("No next page button found or it is disabled.");
            return false;
        }
    }
  
// Simplified scrollDown logic
async function scrollDown() {
    const container = await getContainer();
    console.log("scrollDown called for:", container);

    // Simplified logic to trigger a scroll and wait for changes
    let attempts = 0;
    const maxAttempts = 5; // Adjust based on your needs

    do {
        container.scrollBy(0, 1000); // Adjust scroll step size as needed
        try {
            await waitForDomChanges("#search-results-container", 5000); // Adjust timeout as needed
            console.log("DOM changes detected, attempting to extract data...");
            const results = await extractDataFromPage();
            if (results.length > 0) {
                await storeResultsLocally(results);
                console.log("Data sent to server.");
                attempts = 0; // Reset attempts if data was successfully processed
            } else {
                console.log("No new data found, increasing attempt count.");
                attempts++;
            }
        } catch (error) {
            console.error("Error waiting for DOM changes:", error.message);
            attempts++;
        }
    } while (attempts < maxAttempts);

    if (attempts >= maxAttempts) {
        console.log("Max attempts reached, checking for next page...");
        const nextPageSuccess = await navigateToNextPage();
        if (nextPageSuccess) {
            console.log("Navigated to next page, continuing data extraction...");
            await scrollDown(); // Recursively call scrollDown for the next page
        } else {
            console.log("No further pages or unable to navigate, stopping script.");
        }
    }
}

    
    console.log("mainScript() executing...");
    await scrollDown();
      
}

chrome.webRequest.onCompleted.addListener(
    function(details) {
      // Check if the request was rate-limited
      if (details.statusCode === 429) {
        console.log("Rate limit hit:", details);
        // Optionally, extract the Retry-After header if present
        const retryAfterHeader = details.responseHeaders.find(header => header.name.toLowerCase() === "retry-after");
        if (retryAfterHeader) {
          console.log("Retry after (seconds):", retryAfterHeader.value);
          // Here you could broadcast a message to your content scripts or take other actions
        }
      }
    },
    {urls: ["*://www.example.com/*"]}, // Adjust the pattern to match the URLs you're interested in
    ["responseHeaders"]
  );
  
manifest.json: 

{
  "manifest_version": 3,
  "name": "Golden Thinker Extractor",
  "description": "An extension to extract fields from web pages",
  "version": "1.0",
  "action": {
    "default_popup": "com_goldenthinkerextractor_content_html/popup.html",
    "default_icon": {
      "16": "com_goldenthinkerextractor_images/icon16.png",
      "32": "com_goldenthinkerextractor_images/icon32.png",
      "48": "com_goldenthinkerextractor_images/icon48.png",
      "128": "com_goldenthinkerextractor_images/icon128.png"
    }
  },
  "permissions": [
    "activeTab",
    "scripting",
    "tabs",
    "cookies",
    "storage",
    "declarativeContent",
    "webRequest"
  ],
  "host_permissions": [
    "https://www.goldenthinker.com/",
    "https://www.subjectivetechnologies.com/"
  ],
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"]
    }
  ],
  "background": {
    "service_worker": "background.js"
  },
  "web_accessible_resources": [
    {
      "resources": [
        "com_goldenthinkerextractor_content_html/popup.html",
        "com_goldenthinkerextractor_content_styles/popup.css",
        "com_goldenthinkerextractor_content_styles/style.css",
        "com_goldenthinkerextractor_simulator/user_simulator.js"
      ],
      "matches": ["https://*/*"]
    }
  ],
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'"
  }
}

webpack.config.js: 

const path = require('path');
const CopyPlugin = require('copy-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: {
    content: './src/content.js',
    background: './src/background.js'
  },
  output: {
    path: path.resolve(__dirname, 'build/GoldenThinkerExtractor'),
    filename: '[name].js',
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
          },
        },
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader'],
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: ['file-loader'],
      },
    ],
  },
  plugins: [
    new CopyPlugin({
      patterns: [
        { from: 'src/manifest.json', to: 'manifest.json' },
        { from: 'com_goldenthinkerextractor_images', to: 'com_goldenthinkerextractor_images' },
        { from: 'src/com_goldenthinkerextractor_content_html/popup.html', to: 'com_goldenthinkerextractor_content_html/popup.html' },
        { from: 'src/com_goldenthinkerextractor_content_styles/popup.css', to: 'com_goldenthinkerextractor_content_styles/popup.css' },
        { from: 'src/com_goldenthinkerextractor_content_styles/style.css', to: 'com_goldenthinkerextractor_content_styles/style.css' },
        { from: 'src/com_goldenthinkerextractor_simulator/user_simulator.js', to: 'com_goldenthinkerextractor_simulator/user_simulator.js'}
      ],
    }),
    new CleanWebpackPlugin() 
  ],
  devServer: {
    contentBase: './GoldenThinkerExtractor',
    open: true,
  },
  devtool: 'source-map'

};


User
On the extension side , the error happens at:

          chrome.runtime.sendMessage({ action: "start_web_crawl_message", tab: tabs[0] }, function(response) {
            // Close the popup window after sending the message
            window.close();
          });`
And the when it crashes on the website injected script with the error: 

Uncaught (in promise) Error: A listener indicated an asynchronous response by returning true, but the message channel closed before a response was received
VM828:1 Uncaught ReferenceError: i is not defined
    at a (<anonymous>:1:15)
    at <anonymous>:1:47


In previous versions on git , this issue did not occur. Even in previous versions using webpack. 
What could be the problem ? 